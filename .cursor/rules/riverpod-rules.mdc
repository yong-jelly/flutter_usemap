---
description: "Riverpod 3.x 사용 규칙 - Notifier/AsyncNotifier, codegen 패턴 가이드"
globs: ["lib/**/*.dart"]
alwaysApply: true
---

# Riverpod 3.x 사용 규칙

## 공통

- 상태 관리는 모두 Riverpod으로 통일한다.
- 글로벌 이벤트 버스, 별도 상태관리 라이브러리는 사용하지 않는다.
- ProviderScope는 app/bootstrap.dart에서 한 번만 감싼다.

## Provider 타입

- 서버 데이터/비동기 로직: AsyncNotifier + AsyncValue
- 단순 계산/읽기 전용: Provider / FutureProvider / StreamProvider
- 폼/입력 상태: Notifier 또는 내부 State 클래스 사용

## 코드 생성

- `riverpod_annotation` + `riverpod_generator` + `build_runner` 사용
- 규칙:
  - AsyncNotifier: @riverpod 애너테이션을 클래스에 붙인다.
  - provider 이름은 LLM이 직접 생성하지 않고 codegen에 맡긴다(필요 시 참조만).
- family 사용 시 build 메서드의 인자로 파라미터를 정의한다.

## 예시(AsyncNotifier Controller)

- 논리 예시(실제 코드 생성 시 이 패턴을 유지):

  @riverpod
  class LoginController extends _$LoginController {
    @override
    FutureOr<LoginState> build() {
      // 초기 상태 설정
    }

    Future<void> submit(String email, String password) async {
      // 1) 로딩 상태
      // 2) UseCase 호출
      // 3) 성공/실패에 따라 state 업데이트
    }
  }

- UI에서는:
  - watch: ref.watch(loginControllerProvider)
  - action: ref.read(loginControllerProvider.notifier).submit(...)

## Command 패턴 (비동기 작업 처리)

- 사용자 액션(제출, 삭제, 업데이트 등)은 Controller의 메서드로 처리한다.
- 메서드는 Future<void>를 반환하고, 내부에서 상태 업데이트를 처리한다.
- 에러는 AsyncValue를 통해 UI에 전달한다.

예시:
```dart
Future<void> submitForm(String data) async {
  state = const AsyncValue.loading();
  state = await AsyncValue.guard(() async {
    await useCase.execute(data);
    return success;
  });
}
```

## Result 패턴 (선택적)

- 복잡한 비동기 작업의 경우, Result<T, E> 타입을 사용할 수 있다.
- 단, 간단한 경우에는 AsyncValue만으로 충분하다.