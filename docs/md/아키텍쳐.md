# 프로젝트 아키텍처 가이드

이 문서는 `flutter_usemap` 프로젝트의 설계 원칙, 계층 구조, 데이터 흐름 및 기술 스택에 대해 상세히 설명합니다. 초심자도 프로젝트의 구조를 쉽게 이해하고 개발에 참여할 수 있도록 구성되었습니다.

---

## 1. 아키텍처 개요

우리 프로젝트는 **Feature-first**와 **Clean Architecture (DDD-lite)**의 하이브리드 구조를 채택하고 있습니다.

### 특징
- **Feature-first**: 기능을 중심으로 코드를 응집시킵니다. (예: `auth`, `profile`, `map` 등)
- **Clean Architecture**: 의존성 방향이 항상 내부(Domain)를 향하도록 하여, 외부 라이브러리(Supabase, Dio 등)의 변경이 비즈니스 로직에 영향을 주지 않도록 합니다.
- **Unidirectional Data Flow**: 데이터는 단방향으로 흐르며, 모든 상태는 Riverpod을 통해 관리됩니다.

---

## 2. 계층 구조 (Layered Architecture)

각 기능(Feature)은 다음과 같이 세 가지 주요 계층과 공통 레이어(Core)로 나뉩니다.

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                          Presentation Layer                             │
│       (Pages, Widgets, Controllers - UI & State Management)             │
└───────────────────────────┬─────────────────────────────────────────────┘
                            │ (depends on)
┌───────────────────────────▼─────────────────────────────────────────────┐
│                             Domain Layer                                │
│       (Entities, UseCases, Repository Interfaces - Business Logic)       │
└───────────────────────────▲─────────────────────────────────────────────┘
                            │ (implements)
┌───────────────────────────┴─────────────────────────────────────────────┐
│                             Data Layer                                  │
│       (Models, Repositories Impl, DataSources - Infrastructure)         │
└─────────────────────────────────────────────────────────────────────────┘
                            │ (uses)
┌───────────────────────────▼─────────────────────────────────────────────┐
│                             Core Layer                                  │
│       (DI, Network, Storage, Utils - Cross-cutting Concerns)            │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1) Presentation Layer (`lib/features/<feature>/presentation`)
- **Pages**: 전체 화면을 담당하는 위젯.
- **Widgets**: 화면 내에서 재사용되는 작은 UI 컴포넌트.
- **Controllers**: Riverpod의 `AsyncNotifier`를 사용하여 UI 상태를 관리하고 비즈니스 로직(UseCase)을 호출합니다.
- **규칙**: UI는 오직 `Controller`의 상태를 구독(watch)하고, 사용자의 액션은 `Controller`의 메서드를 통해 전달합니다.

### 2) Domain Layer (`lib/features/<feature>/domain`)
- **Entities**: 비즈니스 모델 (순수 Dart 클래스).
- **UseCases**: 하나의 명확한 비즈니스 행위 (예: `LoginUseCase`, `GetProfileUseCase`).
- **Repositories (Interface)**: 데이터 레이어와 도메인 레이어를 연결하는 추상 인터페이스.
- **규칙**: 외부 라이브러리에 의존하지 않는 가장 순수한 계층입니다.

### 3) Data Layer (`lib/features/<feature>/data`)
- **Models (DTO)**: 네트워크나 로컬 DB에서 사용하는 데이터 포맷. JSON 직렬화/역직렬화를 담당합니다.
- **Repositories (Implementation)**: 도메인 레이어의 인터페이스를 실제로 구현합니다.
- **DataSources**: 외부 API(Supabase, Dio)나 로컬 저장소(Drift)에 직접 접근합니다.
- **규칙**: `Model`을 `Entity`로 변환하여 도메인 계층으로 전달합니다.

### 4) Core Layer (`lib/core`)
- 앱 전반에서 공통으로 사용하는 유틸리티, 네트워크 설정, 로컬 DB 정의 등이 위치합니다.
- `di/`: 전역적으로 사용되는 Provider 주입.
- `network/`: Dio 설정 및 API 예외 처리.
- `offline/`: 네트워크 연결 상태 감지 및 오프라인 큐 관리.
- `storage/`: Drift DB 및 보안 저장소 어댑터.

---

## 3. 데이터 흐름 (Data Flow)

데이터는 아래와 같은 흐름으로 전달됩니다.

### 읽기 요청 (Fetching Data)
```text
[UI (Page)] ──(watch)──► [Controller (Riverpod)]
                                │
                                ▼
[DataSource] ◄──[Repository] ◄──[UseCase]
     │             │             │
     └─(Model)─────┴─(Entity)────┘
```

### 쓰기 요청 (Command/Action)
```text
[UI (Button Click)] ──(read.method)──► [Controller]
                                           │
                                           ▼
[DataSource] ◄──[Repository] ◄──[UseCase] ◄┘
     │
     └─► [Supabase / Local DB]
```

---

## 4. 상태 관리 (Riverpod 3.x)

프로젝트의 모든 상태는 Riverpod을 통해 관리됩니다.

- **Codegen**: `@riverpod` 애너테이션을 사용하여 Provider를 자동 생성합니다.
- **AsyncValue**: 비즈니스 로직의 비동기 상태(Loading, Data, Error)를 안전하게 처리합니다.
- **Controller 패턴**: `AsyncNotifier`를 상속받은 클래스가 상태와 로직을 함께 관리합니다.

### 예시 코드 구조
```dart
@riverpod
class ProfileController extends _$ProfileController {
  @override
  FutureOr<ProfileEntity> build() {
    // 1. 초기 데이터 로드 (UseCase 호출)
    return ref.read(getProfileUseCaseProvider).execute();
  }

  Future<void> updateProfile(ProfileEntity newProfile) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await ref.read(updateProfileUseCaseProvider).execute(newProfile);
      return newProfile;
    });
  }
}
```

---

## 5. 폴더 구조 상세

```text
lib/
├── app/                  # 앱 진입점 및 전역 설정
│   ├── bootstrap.dart    # 초기화 로직 (Supabase, ProviderScope)
│   └── app.dart          # MaterialApp 및 라우터 설정
├── core/                 # 공통 모듈
│   ├── di/               # 전역 의존성 주입
│   ├── network/          # API 클라이언트 및 예외 처리
│   ├── storage/          # Drift DB & Secure Storage
│   └── ui/               # 테마, 공통 위젯
├── features/             # 기능별 모듈
│   └── auth/             # 인증 기능 예시
│       ├── domain/       # 비즈니스 로직
│       ├── data/         # 데이터 소스 및 구현체
│       └── presentation/ # UI 및 컨트롤러
├── router/               # GoRouter 설정
└── main.dart             # main 함수
```

---

## 6. 오프라인 및 동기화 전략

이 프로젝트는 오프라인 우선(Offline-first)을 고려한 구조를 가집니다.

1. **Connectivity**: `connectivity_plus`를 통해 네트워크 상태를 실시간 감지합니다.
2. **Outbox Pattern**: 오프라인 상태에서 발생한 쓰기 요청은 `Drift` DB의 큐에 저장됩니다.
3. **Sync Worker**: 네트워크가 복구되면 큐에 쌓인 요청을 순차적으로 서버에 전송합니다.

---

## 7. 주요 기술 스택

- **Language**: Dart (Flutter SDK)
- **State Management**: Riverpod 3.x
- **Backend/Auth**: Supabase
- **Local DB**: Drift (SQLite)
- **Routing**: GoRouter
- **Networking**: Dio
- **Code Generation**: Freezed, Riverpod Generator, Drift Dev
- **Location**: Geolocator
